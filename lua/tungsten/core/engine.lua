-- engine.lua
-- Passes WolframScript generated by praser/AST.toWolfram to the WolframEngine
----------------------------------------------------------------------------------

local parse   = require("tungsten.core.parser").parse
local cg        = require("tungsten.backends.wolfram")
local toWolfram = (type(cg) == "function" and cg) or cg.to_string
local config = require("tungsten.config")


local M = {}  -- Module table to hold our functions

--- Asynchronously evaluates a math expression represented by an AST.
-- @param ast The abstract syntax tree produced by the LPeg parser.
-- @param numeric (boolean) If true, the expression is evaluated in numeric mode.
-- @param callback A function that receives the evaluated output as its argument.
function M.evaluate_async(ast, numeric, callback)
  -- Convert the AST to a WolframScript code string.
  local code = toWolfram(ast)
  if config.numeric_mode or numeric then
    code = "N[" .. code .. "]"
  end

  -- Get the WolframScript command path from config (defaulting to "wolframscript" if not set)
  local wolfram_path = config.wolfram_path or "wolframscript"

  -- Start the job asynchronously.
  vim.fn.jobstart({ wolfram_path, "-code", code }, {
    stdout_buffered = true,
    on_stdout = function(_, data, _)
      -- Join the data table into a string and trim trailing whitespace.
      local output = table.concat(data, "\n"):gsub("%s+$", "")
      if callback then
        callback(output)
      end
    end,
    on_stderr = function(_, data, _)
      local err = table.concat(data, "\n"):gsub("%s+$", "")
      if err ~= "" then                     -- ← only notify if real content
        vim.notify("WolframScript error: " .. err, vim.log.levels.ERROR)
      end
    end,
  })
end

function M.run_async(input, numeric, callback)
  local ok, ast = pcall(parse, input)
  if not ok or ast == nil then
    vim.notify("Parse error: " .. tostring(ast), vim.log.levels.ERROR)
    return
  end
  return M.evaluate_async(ast, numeric, callback)
end

-- Optional: re‑export the parser so callers can still get the AST
M.parse = parse


return M
