-- engine.lua
-- Passes WolframScript generated by praser/AST.toWolfram to the WolframEngine
----------------------------------------------------------------------------------

local parse   = require("tungsten.core.parser").parse
local cg        = require("tungsten.backends.wolfram")
local toWolfram = (type(cg) == "function" and cg) or cg.to_string
local config = require("tungsten.config")


local M = {}  -- Module table to hold our functions

--- Asynchronously evaluates a math expression represented by an AST.
-- @param ast The abstract syntax tree produced by the LPeg parser.
-- @param numeric (boolean) If true, the expression is evaluated in numeric mode.
-- @param callback A function that receives the evaluated output as its argument.
function M.evaluate_async(ast, numeric, callback)
  -- Convert the AST to a WolframScript code string.
  local code = toWolfram(ast)
  if config.numeric_mode or numeric then
    code = "N[" .. code .. "]"
  end

  -- Get the WolframScript command path from config (defaulting to "wolframscript" if not set)
  local wolfram_path = config.wolfram_path or "wolframscript"

  -- Start the job asynchronously.
  vim.fn.jobstart({ wolfram_path, "-code", code }, {
    stdout_buffered = true,
  })
end

function M.run_async(input, numeric, callback)
  local ok, ast = pcall(parse, input)
  if not ok or ast == nil then
    vim.notify("Parse error: " .. tostring(ast), vim.log.levels.ERROR)
    return
  end
  return M.evaluate_async(ast, numeric, callback)
end

-- Optional: reâ€‘export the parser so callers can still get the AST
M.parse = parse


return M
